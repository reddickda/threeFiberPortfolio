/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
*/

import React, { useEffect, useRef, useState } from 'react'
import { useGLTF, useAnimations } from '@react-three/drei'
import { useFrame, useThree } from "@react-three/fiber";
import * as THREE from 'three'

const baseHandFeet = [0, 2.37, -0.02];

export function Robot(props) {
  const group = useRef()
  const [running, setRunning] = useState(false);
  const { nodes, materials, animations } = useGLTF('/RobotExpressive.glb')
  //Dance, Death Idle, Jump, No, Punch, Running, Sitting, Standing, Thumbsup
  const { actions } = useAnimations(animations, group)
  const {camera} = useThree();

  useEffect(() => {
    if(!running){
      actions.Running.stop();
      actions.Idle.time = 0.0;
      actions.Idle.enabled = true;
      actions.Idle.setEffectiveTimeScale(1.0);
      actions.Idle.setEffectiveWeight(1.0);
      // actions.Idle.crossFadeFrom(actions.Running, 0.5, true);
      actions.Idle.play();
    }else if(running){
      actions.Idle.stop();
      actions.Running.play();
    }
  }, [running]);

  var goal, follow;

  var dir = new THREE.Vector3;
  var a = new THREE.Vector3;
  var b = new THREE.Vector3;
  var coronaSafetyDistance = 0.3;
  var velocity = 0.0;
  var speed = 0.0;


  goal = new THREE.Object3D;
  follow = new THREE.Object3D;
  goal.position.z = -coronaSafetyDistance;
  let keys = {
    a: false,
    s: false,
    d: false,
    w: false
  };

  // var fired = false;
  document.body.addEventListener( 'keydown', function(e) {
    if (e.repeat) { return }
    var key = e.code.replace('Key', '').toLowerCase();
    if ( keys[ key ] !== undefined){ // && !fired)
      // fired=true;
      if(key=='w'){setRunning(true)}
      keys[ key ] = true;
    }
  });
  document.body.addEventListener( 'keyup', function(e) {
    // fired = false;
    if (e.repeat) { return }
    var key = e.code.replace('Key', '').toLowerCase();
    if ( keys[ key ] !== undefined )
      keys[ key ] = false;
      setRunning(false);
  });
  console.log(running)

  useFrame((state, delta) => {
    // mixer?.update(delta);
    camera.lookAt( group.current.position );
   
    speed = 0.0;
  
    if ( keys.w || running ){       
      speed = .03;
    }
    else if ( keys.s )
      speed = -.03;
  
    velocity += ( speed - velocity ) * .3;
    group.current.translateZ( velocity );
  
    if ( keys.a )
    group.current.rotateY(0.05);
    else if ( keys.d )
    group.current.rotateY(-0.05);
    
    a.lerp(group.current.position, 0.4);
    b.copy(goal.position);
    
      dir.copy( a ).sub( b ).normalize();
      const dis = a.distanceTo( b ) - coronaSafetyDistance;
      goal.position.addScaledVector( dir, dis );
      // temp.setFromMatrixPosition(goal.matrixWorld);
      
      // camera.position.lerp(temp, 0.2);
      // camera.translateZ(velocity);

      camera.lookAt( group.current.position );
      // console.log(group.current.position)

    //console.log(camera.position)
})


  return (
    <group ref={group} {...props} dispose={null}>
      <group rotation={[-Math.PI / 2, 0, 0]} scale={100}>
        <primitive object={nodes.Bone} />
      </group>
      <group position={[0, 2.37, -0.02]} rotation={[-Math.PI / 2, 0, 0]} scale={100}>
        <skinnedMesh
          geometry={nodes.HandR_1.geometry}
          material={nodes.HandR_1.material}
          skeleton={nodes.HandR_1.skeleton}
        />
        <skinnedMesh
          geometry={nodes.HandR_2.geometry}
          material={nodes.HandR_2.material}
          skeleton={nodes.HandR_2.skeleton}
        />
      </group>
      <group position={[0, 2.37, -0.02]} rotation={[-Math.PI / 2, 0, 0]} scale={100}>
        <skinnedMesh
          geometry={nodes.HandL_1.geometry}
          material={nodes.HandL_1.material}
          skeleton={nodes.HandL_1.skeleton}
        />
        <skinnedMesh
          geometry={nodes.HandL_2.geometry}
          material={nodes.HandL_2.material}
          skeleton={nodes.HandL_2.skeleton}
        />
      </group>
    </group>
  )
}

useGLTF.preload('/RobotExpressive.glb')
